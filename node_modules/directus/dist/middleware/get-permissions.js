"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@directus/shared/utils");
const lodash_1 = require("lodash");
const database_1 = __importDefault(require("../database"));
const app_access_permissions_1 = require("../database/system-data/app-access-permissions");
const async_handler_1 = __importDefault(require("../utils/async-handler"));
const merge_permissions_1 = require("../utils/merge-permissions");
const users_1 = require("../services/users");
const roles_1 = require("../services/roles");
const cache_1 = require("../cache");
const object_hash_1 = __importDefault(require("object-hash"));
const env_1 = __importDefault(require("../env"));
const getPermissions = (0, async_handler_1.default)(async (req, res, next) => {
    const database = (0, database_1.default)();
    const { systemCache } = (0, cache_1.getCache)();
    let permissions = [];
    if (!req.accountability) {
        throw new Error('"getPermissions" needs to be used after the "authenticate" middleware');
    }
    if (!req.schema) {
        throw new Error('"getPermissions" needs to be used after the "schema" middleware');
    }
    const { user, role, app, admin } = req.accountability;
    const cacheKey = `permissions-${(0, object_hash_1.default)({ user, role, app, admin })}`;
    if (env_1.default.CACHE_PERMISSIONS !== false) {
        const cachedPermissions = await systemCache.get(cacheKey);
        if (cachedPermissions) {
            req.accountability.permissions = cachedPermissions;
            return next();
        }
    }
    if (req.accountability.admin !== true) {
        const permissionsForRole = await database
            .select('*')
            .from('directus_permissions')
            .where({ role: req.accountability.role });
        const requiredPermissionData = {
            $CURRENT_USER: [],
            $CURRENT_ROLE: [],
        };
        permissions = permissionsForRole.map((permissionRaw) => {
            const permission = (0, lodash_1.cloneDeep)(permissionRaw);
            if (permission.permissions && typeof permission.permissions === 'string') {
                permission.permissions = JSON.parse(permission.permissions);
            }
            else if (permission.permissions === null) {
                permission.permissions = {};
            }
            if (permission.validation && typeof permission.validation === 'string') {
                permission.validation = JSON.parse(permission.validation);
            }
            else if (permission.validation === null) {
                permission.validation = {};
            }
            if (permission.presets && typeof permission.presets === 'string') {
                permission.presets = JSON.parse(permission.presets);
            }
            else if (permission.presets === null) {
                permission.presets = {};
            }
            if (permission.fields && typeof permission.fields === 'string') {
                permission.fields = permission.fields.split(',');
            }
            else if (permission.fields === null) {
                permission.fields = [];
            }
            const extractPermissionData = (val) => {
                if (typeof val === 'string' && val.startsWith('$CURRENT_USER.')) {
                    requiredPermissionData.$CURRENT_USER.push(val.replace('$CURRENT_USER.', ''));
                }
                if (typeof val === 'string' && val.startsWith('$CURRENT_ROLE.')) {
                    requiredPermissionData.$CURRENT_ROLE.push(val.replace('$CURRENT_ROLE.', ''));
                }
                return val;
            };
            (0, utils_1.deepMap)(permission.permissions, extractPermissionData);
            (0, utils_1.deepMap)(permission.validation, extractPermissionData);
            (0, utils_1.deepMap)(permission.presets, extractPermissionData);
            return permission;
        });
        if (req.accountability.app === true) {
            permissions = (0, merge_permissions_1.mergePermissions)(permissions, app_access_permissions_1.appAccessMinimalPermissions.map((perm) => ({ ...perm, role: req.accountability.role })));
        }
        const usersService = new users_1.UsersService({ schema: req.schema });
        const rolesService = new roles_1.RolesService({ schema: req.schema });
        const filterContext = {};
        if (req.accountability.user && requiredPermissionData.$CURRENT_USER.length > 0) {
            filterContext.$CURRENT_USER = await usersService.readOne(req.accountability.user, {
                fields: requiredPermissionData.$CURRENT_USER,
            });
        }
        if (req.accountability.role && requiredPermissionData.$CURRENT_ROLE.length > 0) {
            filterContext.$CURRENT_ROLE = await rolesService.readOne(req.accountability.role, {
                fields: requiredPermissionData.$CURRENT_ROLE,
            });
        }
        permissions = permissions.map((permission) => {
            permission.permissions = (0, utils_1.parseFilter)(permission.permissions, req.accountability, filterContext);
            permission.validation = (0, utils_1.parseFilter)(permission.validation, req.accountability, filterContext);
            permission.presets = (0, utils_1.parseFilter)(permission.presets, req.accountability, filterContext);
            return permission;
        });
        if (env_1.default.CACHE_PERMISSIONS !== false) {
            await systemCache.set(cacheKey, permissions);
        }
    }
    req.accountability.permissions = permissions;
    return next();
});
exports.default = getPermissions;
